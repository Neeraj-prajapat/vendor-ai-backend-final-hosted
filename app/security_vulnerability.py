# app/security_vulnerability.py

import os
import time
import json
import logging
import requests
from datetime import datetime, timedelta
from typing import List, Dict, Any, Optional

from fastapi import HTTPException, Depends, Query, BackgroundTasks
from sqlalchemy.orm import Session
from sqlalchemy import desc

from .database import Base, SessionLocal, get_db
from .models import CVE, VulnerabilityAlert
from .schemas import CVEResponse, CVEDetailResponse, VulnerabilityStats, AlertResponse

logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO)

# ----------------------
# NVD Client
# ----------------------
class NVDClient:
    def __init__(self, api_key: Optional[str] = None):
        self.api_key = api_key
        self.base_url = "https://services.nvd.nist.gov/rest/json/cves/2.0"
        # 6.5 seconds per request if no API key, else 0.6 seconds
        self.rate_limit_delay = 0.6 if api_key else 6.5
        self.last_request_time = 0
        
    def _respect_rate_limit(self):
        current_time = time.time()
        time_since_last_request = current_time - self.last_request_time
        
        if time_since_last_request < self.rate_limit_delay:
            sleep_time = self.rate_limit_delay - time_since_last_request
            logger.info(f"Rate limiting: sleeping for {sleep_time:.1f} seconds")
            time.sleep(sleep_time)
        
        self.last_request_time = time.time()
        
    def fetch_cves(self, days: int = 1, results_per_page: int = 100) -> dict:
        try:
            since = (datetime.utcnow() - timedelta(days=days)).strftime("%Y-%m-%dT%H:%M:%S.000")
            end_date = datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%S.000")
            
            params = {
                "resultsPerPage": min(results_per_page, 2000 if self.api_key else 100),
                "pubStartDate": since,
                "pubEndDate": end_date
            }
            
            headers = {"User-Agent": "SOC-CVE-Monitor/1.0"}
            if self.api_key:
                headers["apiKey"] = self.api_key
                
            logger.info(f"Fetching CVEs published since {since}")
            self._respect_rate_limit()
            
            response = requests.get(self.base_url, params=params, headers=headers, timeout=30)
            
            if response.status_code == 403:
                logger.error("Rate limit exceeded")
                raise HTTPException(status_code=429, detail="Rate limit exceeded")
                
            response.raise_for_status()
            return response.json()
            
        except requests.RequestException as e:
            logger.error(f"Error fetching CVEs from NVD: {e}")
            raise HTTPException(status_code=500, detail=f"NVD API error: {e}")

# ----------------------
# Vulnerability Service
# ----------------------
class VulnerabilityService:
    def __init__(self, db: Session):
        self.db = db
        api_key = os.getenv("NVD_API_KEY")
        if api_key:
            logger.info("NVD API key found - using enhanced rate limits")
        else:
            logger.info("No NVD API key - using standard rate limits")
        self.nvd_client = NVDClient(api_key)

    def parse_cve_data(self, cve_item: dict) -> dict:
        cve = cve_item.get("cve", {})
        
        # Basic info
        cve_id = cve.get("id", "")
        descriptions = cve.get("descriptions", [])
        description = next((d.get("value", "") for d in descriptions if d.get("lang") == "en"), "")
        
        # Dates
        published = cve.get("published", "")
        last_modified = cve.get("lastModified", "")
        
        # CVSS scores
        metrics = cve.get("metrics", {})
        cvss_v3 = metrics.get("cvssMetricV31", [])
        cvss_v2 = metrics.get("cvssMetricV2", [])
        
        cvss_v3_score = None
        cvss_v3_severity = None
        cvss_details = {}
        
        if cvss_v3:
            cvss_data = cvss_v3[0].get("cvssData", {})
            cvss_v3_score = cvss_data.get("baseScore")
            cvss_v3_severity = cvss_data.get("baseSeverity")
            cvss_details = {
                "attack_vector": cvss_data.get("attackVector"),
                "attack_complexity": cvss_data.get("attackComplexity"),
                "privileges_required": cvss_data.get("privilegesRequired"),
                "user_interaction": cvss_data.get("userInteraction"),
                "scope": cvss_data.get("scope"),
                "confidentiality_impact": cvss_data.get("confidentialityImpact"),
                "integrity_impact": cvss_data.get("integrityImpact"),
                "availability_impact": cvss_data.get("availabilityImpact")
            }
        
        cvss_v2_score = None
        if cvss_v2:
            cvss_v2_score = cvss_v2[0].get("cvssData", {}).get("baseScore")
        
        # CWE
        weaknesses = cve.get("weaknesses", [])
        cwe_id = None
        if weaknesses:
            cwe_descriptions = weaknesses[0].get("description", [])
            if cwe_descriptions:
                cwe_id = cwe_descriptions[0].get("value", "")
        
        # References
        references = [ref.get("url", "") for ref in cve.get("references", [])]
        
        # Affected products
        configurations = cve.get("configurations", [])
        affected_products = []
        vendor_info = set()
        
        for config in configurations:
            nodes = config.get("nodes", [])
            for node in nodes:
                cpe_matches = node.get("cpeMatch", [])
                for match in cpe_matches:
                    if match.get("vulnerable", False):
                        criteria = match.get("criteria", "")
                        affected_products.append(criteria)
                        parts = criteria.split(":")
                        if len(parts) >= 4:
                            vendor_info.add(f"{parts[3]}:{parts[4]}")
        
        return {
            "cve_id": cve_id,
            "description": description,
            "published_date": datetime.fromisoformat(published.replace("Z", "+00:00")) if published else None,
            "last_modified": datetime.fromisoformat(last_modified.replace("Z", "+00:00")) if last_modified else None,
            "cvss_v3_score": cvss_v3_score,
            "cvss_v3_severity": cvss_v3_severity,
            "cvss_v2_score": cvss_v2_score,
            "cwe_id": cwe_id,
            "references": json.dumps(references),
            "vendor_project": "|".join(vendor_info),
            "product": "",
            "version_affected": json.dumps(affected_products),
            **cvss_details
        }
    
    def sync_cves(self, days: int = 1) -> Dict[str, int]:
        try:
            data = self.nvd_client.fetch_cves(days=days)
            vulnerabilities = data.get("vulnerabilities", [])
            
            new_cves = 0
            updated_cves = 0
            
            for vuln_item in vulnerabilities:
                try:
                    cve_data = self.parse_cve_data(vuln_item)
                    cve_id = cve_data["cve_id"]
                    if not cve_id:
                        continue
                    
                    existing_cve = self.db.query(CVE).filter_by(cve_id=cve_id).first()
                    
                    if existing_cve:
                        if existing_cve.last_modified != cve_data["last_modified"]:
                            for key, value in cve_data.items():
                                if key != "cve_id":
                                    setattr(existing_cve, key, value)
                            updated_cves += 1
                    else:
                        new_cve = CVE(**cve_data)
                        self.db.add(new_cve)
                        new_cves += 1
                        # Create alerts for critical vulnerabilities
                        if cve_data.get("cvss_v3_score", 0) >= 9.0:
                            alert = VulnerabilityAlert(
                                cve_id=cve_id,
                                alert_type="critical",
                                message=f"Critical vulnerability detected: {cve_id} (CVSS: {cve_data['cvss_v3_score']})"
                            )
                            self.db.add(alert)
                except Exception as e:
                    logger.error(f"Error processing CVE {cve_data.get('cve_id', 'unknown')}: {e}")
                    continue
            
            self.db.commit()
            logger.info(f"CVE sync complete: {new_cves} new, {updated_cves} updated")
            return {"new_cves": new_cves, "updated_cves": updated_cves}
        except Exception as e:
            self.db.rollback()
            logger.error(f"Error syncing CVEs: {e}")
            raise

# ----------------------
# Dependency for VulnerabilityService
# ----------------------
def get_vulnerability_service(db: Session = Depends(get_db)) -> VulnerabilityService:
    return VulnerabilityService(db)

# ----------------------
# API Endpoints for Vulnerabilities
# ----------------------
async def sync_vulnerabilities(
    background_tasks: BackgroundTasks,
    days: int = Query(1, description="Number of days to fetch CVEs for"),
    db: Session = Depends(get_db)
):
    """Schedule an asynchronous CVE sync."""
    def sync_task():
        service = VulnerabilityService(db)
        return service.sync_cves(days)
    background_tasks.add_task(sync_task)
    return {
        "status": "sync_scheduled",
        "message": f"Vulnerability sync for last {days} days has been scheduled",
        "estimated_time": f"~{days * 2} minutes"
    }

async def get_vulnerabilities(
    limit: int = Query(50, description="Number of CVEs to return"),
    severity: Optional[str] = Query(None, description="Filter by severity (CRITICAL, HIGH, MEDIUM, LOW)"),
    vendor: Optional[str] = Query(None, description="Filter by vendor"),
    days: Optional[int] = Query(None, description="Filter by days since publication"),
    unanalyzed_only: bool = Query(False, description="Show only unanalyzed CVEs"),
    db: Session = Depends(get_db)
) -> List[CVEResponse]:
    """Get a list of CVEs, optionally filtered."""
    query = db.query(CVE)
    if severity:
        query = query.filter(CVE.cvss_v3_severity == severity.upper())
    if vendor:
        query = query.filter(CVE.vendor_project.ilike(f"%{vendor}%"))
    if days:
        since = datetime.utcnow() - timedelta(days=days)
        query = query.filter(CVE.published_date >= since)
    if unanalyzed_only:
        query = query.filter(CVE.is_analyzed == False)
    cves = query.order_by(desc(CVE.published_date)).limit(limit).all()
    return [
        CVEResponse(
            id=cve.id,
            cve_id=cve.cve_id,
            description=cve.description or "",
            published_date=cve.published_date,
            cvss_v3_score=cve.cvss_v3_score,
            cvss_v3_severity=cve.cvss_v3_severity,
            vendor_project=cve.vendor_project,
            product=cve.product,
            cwe_id=cve.cwe_id,
            attack_vector=cve.attack_vector,
            is_analyzed=cve.is_analyzed,
            created_at=cve.created_at
        )
        for cve in cves
    ]

async def get_vulnerability_detail(
    cve_id: str,
    db: Session = Depends(get_db)
) -> CVEDetailResponse:
    """Get detailed information about a single CVE."""
    cve = db.query(CVE).filter(CVE.cve_id == cve_id).first()
    if not cve:
        raise HTTPException(status_code=404, detail="CVE not found")
    return CVEDetailResponse(
        id=cve.id,
        cve_id=cve.cve_id,
        description=cve.description or "",
        published_date=cve.published_date,
        last_modified=cve.last_modified,
        cvss_v3_score=cve.cvss_v3_score,
        cvss_v3_severity=cve.cvss_v3_severity,
        cvss_v2_score=cve.cvss_v2_score,
        vendor_project=cve.vendor_project,
        product=cve.product,
        version_affected=cve.version_affected,
        cwe_id=cve.cwe_id,
        references=cve.references,
        attack_vector=cve.attack_vector,
        attack_complexity=cve.attack_complexity,
        privileges_required=cve.privileges_required,
        user_interaction=cve.user_interaction,
        scope=cve.scope,
        confidentiality_impact=cve.confidentiality_impact,
        integrity_impact=cve.integrity_impact,
        availability_impact=cve.availability_impact,
        is_analyzed=cve.is_analyzed,
        created_at=cve.created_at
    )

async def get_vulnerability_stats(db: Session = Depends(get_db)) -> VulnerabilityStats:
    """Get aggregate CVE statistics."""
    total_cves = db.query(CVE).count()
    critical_count = db.query(CVE).filter(CVE.cvss_v3_severity == "CRITICAL").count()
    high_count = db.query(CVE).filter(CVE.cvss_v3_severity == "HIGH").count()
    medium_count = db.query(CVE).filter(CVE.cvss_v3_severity == "MEDIUM").count()
    low_count = db.query(CVE).filter(CVE.cvss_v3_severity == "LOW").count()
    recent_7_days = db.query(CVE).filter(
        CVE.published_date >= datetime.utcnow() - timedelta(days=7)
    ).count()
    unanalyzed_count = db.query(CVE).filter(CVE.is_analyzed == False).count()
    return VulnerabilityStats(
        total_cves=total_cves,
        critical_count=critical_count,
        high_count=high_count,
        medium_count=medium_count,
        low_count=low_count,
        recent_7_days=recent_7_days,
        unanalyzed_count=unanalyzed_count,
        last_updated=datetime.utcnow().isoformat()
    )

async def mark_analyzed(
    cve_id: str,
    db: Session = Depends(get_db)
):
    """Mark a given CVE as analyzed."""
    cve = db.query(CVE).filter(CVE.cve_id == cve_id).first()
    if not cve:
        raise HTTPException(status_code=404, detail="CVE not found")
    cve.is_analyzed = True
    db.commit()
    return {"status": "success", "message": f"CVE {cve_id} marked as analyzed"}

async def get_alerts(
    limit: int = Query(20, description="Number of alerts to return"),
    unread_only: bool = Query(False, description="Show only unread alerts"),
    db: Session = Depends(get_db)
) -> List[AlertResponse]:
    """Fetch vulnerability alerts."""
    query = db.query(VulnerabilityAlert)
    if unread_only:
        query = query.filter(VulnerabilityAlert.is_read == False)
    alerts = query.order_by(desc(VulnerabilityAlert.created_at)).limit(limit).all()
    return [
        AlertResponse(
            id=alert.id,
            cve_id=alert.cve_id,
            alert_type=alert.alert_type,
            message=alert.message,
            is_read=alert.is_read,
            created_at=alert.created_at
        )
        for alert in alerts
    ]

# ----------------------
# Router Registration
# ----------------------
def register_vulnerability_routes(app):
    app.add_api_route("/api/vulnerabilities/sync", sync_vulnerabilities, methods=["POST"])
    app.add_api_route("/api/vulnerabilities", get_vulnerabilities, methods=["GET"])
    app.add_api_route("/api/vulnerabilities/{cve_id}", get_vulnerability_detail, methods=["GET"])
    app.add_api_route("/api/vulnerabilities/stats", get_vulnerability_stats, methods=["GET"])
    app.add_api_route("/api/vulnerabilities/{cve_id}/analyze", mark_analyzed, methods=["POST"])
    app.add_api_route("/api/vulnerabilities/alerts", get_alerts, methods=["GET"])
